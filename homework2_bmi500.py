# -*- coding: utf-8 -*-
"""Homework2_BMI500

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u8ck3P44TkQqsOD-EpTYwLKgqfovkt-J
"""

import math
import numpy as np
import timeit
from statistics import mean
import time
from tqdm import tqdm
import matplotlib.pyplot as plt
import cProfile
import re
cProfile.run('re.compile("foo|bar")')

"""Function to calculate the Leibniz sum (Question 1)"""

def Leibniz_calculator(n):
  sum = 0
  for k in range(0,n):

    sum += (math.pow(-1,k))/((2*k)+1)

  return sum

"""Implementations of the different functions (Question 2)"""

def pre_sum_Leibniz_cal(k):
  return ((math.pow(1,k))/((2*k)+1))

def Leibniz_calculator_modulo(n):
  sum_Lei = 0
  for k in range(0,n):
    if (k%2==0):
      sum_Lei += pre_sum_Leibniz_cal(k)
    else:
      sum_Lei -= pre_sum_Leibniz_cal(k)

  return sum_Lei

def Leibniz_calculator_minus_one_pow_n(n):
  sum_Lei = 0
  for k in range(0,n):
    sum_Lei += math.pow(-1,k) * pre_sum_Leibniz_cal(k)

  return (sum_Lei)

def Leibniz_calculator_list(n):
  sum_Lei = []
  for k in range(0,n):
    sum_Lei.append(math.pow(-1,k) * pre_sum_Leibniz_cal(k))

  return(sum(sum_Lei))

def Leibniz_calculator_set(n):
  sum_Lei = set()
  for k in range(0,n):
    sum_Lei.add(math.pow(-1,k) * pre_sum_Leibniz_cal(k))

  return(sum(sum_Lei))

def Leibniz_calculator_dict(n):
  sum_Lei = {"Arr_of_sums": []}
  for k in range(0,n):
    sum_Lei["Arr_of_sums"].append(math.pow(-1,k) * pre_sum_Leibniz_cal(k))

  return(sum(sum_Lei["Arr_of_sums"]))

def Leibniz_calculator_np_arr(n):
  sum_Lei = np.array([])
  for k in range(0,n):
    pre_sum = (math.pow(-1,k) * pre_sum_Leibniz_cal(k))
    sum_Lei = np.append(sum_Lei, pre_sum)

  return(sum(sum_Lei))

def Leibniz_calculator_arr_idx(n):
  sum_Lei = np.array([])
  for k in range(0,n):
    pre_sum = (math.pow(-1,k) * pre_sum_Leibniz_cal(k))
    sum_Lei = np.append(sum_Lei, pre_sum)

  return(sum(sum_Lei[::2]) + sum(sum_Lei[1::2]))

def Leibniz_calculator_non_alt(n):
  sum_Lei = []
  for k in range(0,n):
    pre_sum = (math.pow(-1,k) * pre_sum_Leibniz_cal(k))
    sum_Lei.append(pre_sum)
    
  if len(sum_Lei)%2 == 1:
    sum_Lei.append(0)

  reshaped_arr_after_clustering_all_consecutive_elements = np.reshape(sum_Lei, (-1, 2))


  sum_Lei_clustered = []
  for consecutive_elelemts in reshaped_arr_after_clustering_all_consecutive_elements:
    sum_Lei_clustered.append(sum(consecutive_elelemts))


  return(sum(sum_Lei_clustered))

def speed_cal(func_name,n):
  start = time.time()
  eval(f'{func_name}(n)')
  end = time.time()

  return((end - start) * 1000.0)

"""Speed and accuracy estimator (Question 3)"""

def pi_accuracy_calculator_and_timeestimator(array_of_elements):
  speed0,speed1,speed2,speed3,speed4,speed5,speed6,speed7 = [],[],[],[],[],[],[],[]
  acc0,acc1,acc2,acc3,acc4,acc5,acc6,acc7 = [],[],[],[],[],[],[],[]
  speed = []
  acc = []

  array_of_functions = ['modulo','multiply_neg_one_pow_n','using_list','using_sets','using_dict','using_np_arr','using_arr_idx','using_consecutive_ele']


  for n in tqdm(range(0,len(array_of_elements))):


    speed0.append(speed_cal('Leibniz_calculator_modulo',array_of_elements[n]))
    speed1.append(speed_cal('Leibniz_calculator_minus_one_pow_n',array_of_elements[n]))
    speed2.append(speed_cal('Leibniz_calculator_list',array_of_elements[n]))
    speed3.append(speed_cal('Leibniz_calculator_set',array_of_elements[n]))
    speed4.append(speed_cal('Leibniz_calculator_dict',array_of_elements[n]))
    speed5.append(speed_cal('Leibniz_calculator_np_arr',array_of_elements[n]))
    speed6.append(speed_cal('Leibniz_calculator_arr_idx',array_of_elements[n]))
    speed7.append(speed_cal('Leibniz_calculator_non_alt',array_of_elements[n]))

    


    



    acc0.append(1 - abs(math.pi - (4*Leibniz_calculator_modulo(n))) / (math.pi + (4*Leibniz_calculator_modulo(n))))
    acc1.append(1 - abs(math.pi - (4*Leibniz_calculator_minus_one_pow_n(n))) / (math.pi + (4*Leibniz_calculator_minus_one_pow_n(n))))
    acc2.append(1 - abs(math.pi - (4*Leibniz_calculator_list(n))) / (math.pi + (4*Leibniz_calculator_list(n))))
    acc3.append(1 - abs(math.pi - (4*Leibniz_calculator_set(n))) / (math.pi + (4*Leibniz_calculator_set(n))))
    acc4.append(1 - abs(math.pi - (4*Leibniz_calculator_dict(n))) / (math.pi + (4*Leibniz_calculator_dict(n))))
    acc5.append(1 - abs(math.pi - (4*Leibniz_calculator_np_arr(n))) / (math.pi + (4*Leibniz_calculator_np_arr(n))))
    acc6.append(1 - abs(math.pi - (4*Leibniz_calculator_arr_idx(n))) / (math.pi + (4*Leibniz_calculator_arr_idx(n))))
    acc7.append(1 - abs(math.pi - (4*Leibniz_calculator_non_alt(n))) / (math.pi + (4*Leibniz_calculator_non_alt(n))))



  speed.append([mean(speed0),mean(speed1),mean(speed2),mean(speed3),mean(speed4),mean(speed5),mean(speed6)])
  acc.append([mean(acc0),mean(acc1),mean(acc2),mean(acc3),mean(acc4),mean(acc5),mean(acc6)])



  print(f"\nFastest function: {array_of_functions[np.argmin(speed[0])]}\n")
  print(f"Most accurate function: {array_of_functions[np.argmax(acc[0])]}\n")
  print(f'{array_of_functions}\n')
  print(f'Average time taken for all functions{speed[0]}\n')
  print(f'Accuracy scores for all functions : {acc[0]}')

arr = list(range(1000))

pi_accuracy_calculator_and_timeestimator(arr)

"""**All the functions implemented have the same accuracy. Although, the modulo function is the fastest when compared to the rest. That is the function I would use to pi as that takes the least time to compute for pi. It makes sense why the modulo function takes the least time, because it has the least number of operations to be performed before returning the Leibniz sum.**

---



---

Graph plotter of absolute error (Question 4)
"""

def graph_plotter(list_of_ele):
  logged_list = []
  for n in list_of_ele:

    logged_list.append(abs(math.pi - (4*Leibniz_calculator_list(n))) / (math.pi + (4*Leibniz_calculator_list(n))))



  
  plt.figure(figsize=(10,10))
  plt.xlabel("log_n")
  plt.ylabel("log_abs_err")
  plt.xscale("log")
  plt.yscale("log")
  plt.title("Absolute Err vs No of Terms convergence plot")
  plt.plot(list_of_ele,logged_list)
  plt.show()

graph_plotter(list(range(1000)))

"""Would you do anything differently for computing Ï€ using the Leibniz formula
if you were using Matlab instead of Python? (Question 5)

---



---

Apart from following the MATLAB nomenclature(syntax) of writing code, I would not do anything differently. A very weird thing I have noticed on MATLAB is the speed of an operation depends on the version of MATLAB I am running. Maybe, I would find the optimal version before trying to compute the Leibniz formula. In python though, the speed of the function computation depends on the processing power of the device it is being run on.
"""